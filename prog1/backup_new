#!/bin/bash
TMP=tmp$$ #Create temp file name variable
# Set up trap for Interupt, Hangup, and Terminate
# trap will delete temp files and exit with code 1
trap "rm -rf $TMP*; exit 1" INT HUP TERM
# Function: print_usage_text
# Arguments: None
# Description: prints usage text and exits with code 1
# Pre-Condition: Incorrect Syntax
# Post-Condition: script terminated
print_usage_exit () {
  printf "./stats {-rows|-cols} [file]\n" 1>&2
  exit 1
}
# Function: get_average_file
# Arguments: $1: filename
# Description: computes average and appends to file named $TMPavg
# Pre-Condition: file of integers delimited by newlines
# Post-Condition: avg appended to $TMPavg file, echo count for capture
get_average_file () {
  local count=0; local sum=0
  while read num; do
    count=`expr $count + 1`
    sum=`expr $sum + $num`
  done < $1
  echo $(( (sum + (count / 2)) / count  )) >> "${TMP}avg"
  echo $count
}
# Function: get_median_file
# Arguments: $1: filename $2: count of numbers in file
# Description: computes median and appends to file named $TMPmed
# Pre-Condition: sorted file of integers delimited by newline
# Post-Condition: median appended to $TMPmed file
get_median_file () {
  sort -n $1 -o $1
  local med_index=$2
  if [[ $((med_index % 2)) == 0  ]]; then
    med_index=$(( ($med_index + 1) / 2 + 1  ))
  else 
    med_index=$(( ($med_index + 1) / 2 )); 
  fi
  cut -d$'\n' -f$med_index $1 >> "${TMP}med"
}
# Function: create_temp_files
# Arguments: $1: [-row | -col] $2: file or stdin to read from
# Description: if -row, creates file for each row delimited by newline
#              if -col, creates file for each col delimited by newline
# Pre-Condition: information in file or stdin
# Post-Condition: each row or col has its own temp file, # files returned
create_temp_files () {
  local count=0; 
	if [[ $1 == -r* ]]; then
		while read line; do
			for num in $line; do 
				echo $num >> "${TMP}curr"
      done
      count=$(get_average_file "${TMP}curr")
      get_median_file "${TMP}curr" $count
      rm -f "${TMP}curr"    
		done < $2
	elif [[ $1 == -c* ]]; then
    cat $2 > "${TMP}col"
    local colNum=$(egrep ".{$(wc -L < $2)}" < $2 | wc -w )
    echo $colNum; exit 0
    for (( i=1; i <= colNum; i++  )); do
		  while read line; do
        local val=$( cut -d$'\t' -f$i <<< $line )
        if [[ -n $val  ]]; then echo $val >> "${TMP}curr"; fi
		  done < "${TMP}col"
      count=$(get_average_file "${TMP}curr")
      get_median_file "${TMP}curr" $count
      rm -f "${TMP}curr"
    done
	else print_usage_exit; fi
	echo $count
}
#### MAIN FUNCTION ####
# check for proper number of arguments, if incorrect print_usage_exit
if [[ $# < 1 || $# > 2 ]]; then
  print_usage_exit
else
  count=$(create_temp_files $1 ${2:-/dev/stdin})
  echo $count; exit 0
  if [[ $1 == -r* ]]; then
    printf "%s\t%s\n" "Average" "Median"
    for (( i=1; i <= count; i++ )); do
      printf "$( cut -d$'\n' -f$i "${TMP}avg"  )\t"    
      printf "$( cut -d$'\n' -f$i "${TMP}med"  )\n"    
    done
  else
    printf "Averages:\n"
    while read num; do printf "%d\t" "$num"; done < "${TMP}avg"
    printf "\nMedians:\n"
    while read num; do printf "%d\t" "$num"; done < "${TMP}med"
    echo
  fi
fi
rm -rf $TMP*
