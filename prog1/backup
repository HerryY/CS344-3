#!/bin/bash

TMP=tmp$$ #Create temp file name variable
# Set up trap for Interupt, Hangup, and Terminate
# trap will delete temp files and exit with code 1
trap "rm -rf $TMP; exit 1" INT HUP TERM

# Function: print_usage_text
# Arguments: None
# Description: prints usage text and exits with code 1
# Pre-Condition: Incorrect Syntax
# Post-Condition: script terminated
print_usage_exit () {
  printf "./stats {-rows|-cols} [file]\n" 1>&2
  exit 1
}

# Function: create_temp_files
# Arguments: $1: [-row | -col] $2: file or stdin to read from
# Description: if -row, creates file for each row delimited by newline
#              if -col, creates file for each col delimited by newline
# Pre-Condition: information in file or stdin
# Post-Condition: each row or col has its own temp file, # files returned
create_temp_files () {
	local count=0
	if [[ $1 == -r* ]]; then
		while read line; do
			if [[ -z $line ]]; then break; fi
			for num in $line; do 
				[[ -d $TMP ]] || mkdir $TMP && echo $num >> $TMP/$TMP$count
      done
      count=`expr $count + 1`
		done < $2
	elif [[ $1 == -c* ]]; then
		while read line; do
			if [[ -z $line ]]; then break; fi
      local current=0
			for num in $line; do
				[[ -d $TMP ]] || mkdir $TMP && echo $num >> $TMP/$TMP$current
				current=`expr $current + 1`
			done
			if [[ $current > $count ]]; then count=$current; fi
		done < $2
	else print_usage_exit; fi
	return $count
}
# Function: get_average_file
# Arguments: $1: filename
# Description: computes average and appends to file named $TMPavg
# Pre-Condition: file of integers delimited by newlines
# Post-Condition: avg appended to $TMPavg file, echo count for capture
get_average_file () {
  local count=0; local sum=0
  while read num; do
    count=`expr $count + 1`
    sum=`expr $sum + $num`
  done < $1
  echo $(( (sum + (count / 2)) / count  )) >> "$TMP/${TMP}avg"
  echo $count
}
# Function: get_median_file
# Arguments: $1: filename $2: count of numbers in file
# Description: computes median and appends to file named $TMPmed
# Pre-Condition: sorted file of integers delimited by newline
# Post-Condition: median appended to $TMPmed file
get_median_file () {
  local med_index=$2
  if [[ $((med_index % 2)) == 0  ]]; then
    med_index=$(( ($med_index + 1) / 2 + 1  ))
  else
    med_index=$(( ($med_index + 1) / 2 ))
  fi
  cut -d$'\n' -f$med_index $1 >> "$TMP/${TMP}med"
}

# check for proper number of arguments, if incorrect print_usage_exit
if [[ $# < 1 || $# > 2 ]]; then
  print_usage_exit
else 
  create_temp_files $1 ${2:-/dev/stdin}
  files=$?
  if [[ $files == 0  ]]; then exit 0; fi
  for (( i=0; i < files; i++  )); do
    sort -n $TMP/$TMP$i -o $TMP/$TMP$i
    count=$(get_average_file $TMP/$TMP$i)
    get_median_file $TMP/$TMP$i $count
  done
  if [[ $1 == -r* ]]; then
    printf "%s\t%s\n" "Average" "Median"
    for (( i=0; i < files; i++ )); do
      printf "$( cut -d$'\n' -f$((i+1)) $TMP/${TMP}avg  )\t"    
      printf "$( cut -d$'\n' -f$((i+1)) $TMP/${TMP}med  )\n"    
    done
  else
    printf "Averages:\n"
    while read num; do printf "%d\t" "$num"; done < "$TMP/${TMP}avg"
    printf "\nMedians:\n"
    while read num; do printf "%d\t" "$num"; done < "$TMP/${TMP}med"
    echo
  fi
  rm -rf $TMP
fi
